{% extends "sample.html" %}

{% block headauthor %}Michael Deal <mudcube@gmail.com>{% endblock %}
{% block pageauthor %}{% profilelinks mdeal %}{% endblock %}
{% block headtitle %}Typographic effects in &lt;canvas&gt;{% endblock %}
{% block pagetitle %}Typographic effects in &lt;canvas&gt;{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}Typographic effects in &lt;canvas&gt;{% endblock %}
{% block date %}March 1, 2011{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="opera supported"></span>
<span class="ie"></span>
<span class="safari supported"></span>
<span class="ff supported"></span>
<span class="chrome supported"></span>
{% endblock %}

{% block iscompatible %}
  return !!Modernizr.canvas
{% endblock %}

{% block content %}
  <h2 id="toc-introduction">My Background</h2>

  &lt;canvas&gt; entered my awareness in 2006 when Firefox v2.0 was released<span class="s7">.&nbsp; An article on <a href="http://ajaxian.com/">Ajaxian</a>, describing the transformation matrix, inspired me to create my first &lt;canvas&gt; web-app; <a href="http://www.colorjack.com/sphere/">Color Sphere</a> (2007).&nbsp; Which immersed me into the world of colors, and graphic primitives; inspiring the creation of <a href="http://mugtug.com/sketchpad/">Sketchpad</a> (2007-2008) in an effort to put together an application &ldquo;better than Paint&rdquo; in the browser.
  <p> These experiments eventually led to the creation of the startup Mugtug with my long-time friend Charles Pritchard.&nbsp; We&rsquo;re developing <a href="http://mugtug.com/darkroom/">Darkroom</a> in HTML5 &lt;canvas&gt;.&nbsp; Darkroom is a non-destructive photo-sharing app, combining the powers pixel-based image filters with vector-based typography, stamps and brushes.&nbsp; Please visit our <a href="">Kickstarter</a> page for more information on our project, we could use your help!

  <h2 id="toc-topic">HTML5:&nbsp; Text-Effects</h2>

   <p><img src="./media/pastedGraphic.png" alt="pastedGraphic.png" /><br />
	 &lt;canvas&gt; brings Javascript programmers full-control of the <i>colors</i>, <i>vectors</i> and <i>pixels</i> on their screens&mdash;the visual makeup of the monitor. &nbsp;
   <p> The following examples deal with one area in &lt;canvas&gt; that hasn&rsquo;t gotten much attention;&nbsp; creating <i>text-effects</i>.&nbsp; The variety of text-effects that can be created in &lt;canvas&gt; are as vast as you can imagine&mdash;these demos cover a sub-section of what is possible.&nbsp; Although we&rsquo;re dealing with &ldquo;text&rdquo; in this article, the methods can be applied to <i>any vector objects</i>; creating exciting visuals in games, and other applications:
   <p>
   <li><a href="#text-shadow">Text-Shadows in &lt;canvas&gt;.</a><br />
	 <i>CSS-like</i> text-effects in &lt;canvas&gt; creating clipping masks, finding metrics in &lt;canvas&gt;, and using the shadow property.
	 <p>
   <li><a href="#neon-rainbow">Neon-rainbow, zebra-reflection&mdash;chaining effects.</a><br />
	 <i>Photoshop-like</i> text-effects in &lt;canvas&gt; examples of using globalCompositeOperation, createLinearGradient, createPattern.&nbsp;
	 <p>
   <li><a href="#inner-shadow">Inner &amp; outer shadows in &lt;canvas&gt;</a><br />
	 Revealing a <i>little known feature</i>; using clockwise vs. anti-clockwise winding to create the inverse of a drop-shadow (the <i>inner-shadow</i>).
	 <p>
   <li><a href="#spaceage">Spaceage&mdash;generative effect.</a><br />
	 <i>Generative based</i> text-effect in &lt;canvas&gt; using hsl() color-cycling mapped to sine/cosine waves to create the feeling of motion.
	 <p>
	 <h2 id="text-shadow"><b>Text-Shadows in &lt;canvas&gt;</b></h2>
	 One of my favorite additions to CSS3 specs (along with border-radius, web-gradients, and others) is the ability to create shadows.&nbsp; It&rsquo;s important to realize the differences between CSS and &lt;canvas&gt; shadows, specifically:
	 <p> CSS uses two methods; <i>box-shadow</i> for box-elements, such as div, span, and so on; and <i>text-shadow</i> for text content. &nbsp;
	 <p> &lt;canvas&gt; has one type of shadow; it&rsquo;s used for all the vector objects; ctx.moveTo, ctx.lineTo, ctx.bezierCurveTo, ctx.quadradicCurveTo, ctx.arc, ctx.rect, ctx.fillText, ctx.strokeText, and so on. To create a shadow in &lt;canvas&gt;, tap into these four properties:
	 <p> <b>ctx.shadowColor</b> = &ldquo;red&rdquo; // string<br />
	   Color of the shadow;&nbsp; RGB, RGBA, HSL, HEX, and other inputs are valid.
	 <p> <b>ctx.shadowOffsetX</b> = 0; // integer<br />
	   Horizontal distance of the shadow, in relation to the text.
	 <p> <b>ctx.shadowOffsetY</b> = 0; // integer<br />
	   Vertical distance of the shadow, in relation to the text.
	 <p> <b>ctx.shadowBlur</b> = 10; // integer<br />
	   Blurring effect to the shadow, the larger the value, the greater the blur.
	 <p> To get things started, let&rsquo;s see how &lt;canvas&gt; can emulate CSS effects.&nbsp; Searching through Google images for &ldquo;css text-shadow&rdquo; led to a few great demos for us to emulate;&nbsp; <a href="http://line25.com/articles/using-css-text-shadow-to-create-cool-text-effects">Line25</a>, and <a href="http://lab.simurai.com/css/css3d/">Stereoscopic</a>, and <a href="http://pgwebdesign.net/blog/3d-css-shadow-text-tutorial">Shadow 3D</a>. &nbsp;
	 <p>
	 <p><img src="./media/pastedGraphic_1.png" alt="pastedGraphic_1.png" width="300" height="162" /><br />
	   The stereoscopic 3D effect (see <a href="http://en.wikipedia.org/wiki/Anaglyph_image">Anaglyph image</a> for more) is an example of a simple line of code, put to great use.&nbsp; With the following line of CSS, we can create the illusion of depth when viewed with 3D red/cyan glasses (the kind they give you at 3D movies):
	 <pre class="prettyprint">
	 text-shadow: -0.06em 0 0 red, 0.06em 0 0 cyan;
	 </pre>
	 <p> There are two things to notice when converting this string to &lt;canvas&gt;&nbsp;
	 <p> (1) There is no shadow-blur (the third value), so there is no reason to actually run shadow, as fillText would create the same results:<br />
	 <pre class="prettyprint">
	 var text = &ldquo;Hello world!&rdquo;
	 ctx.fillStyle = &ldquo;#000&rdquo;
	 ctx.fillText(text, -7, 0);
	 ctx.fillStyle = &ldquo;red&rdquo;
	 ctx.fillText(text, 0, 0);
	 ctx.fillStyle = &ldquo;cyan&rdquo;
	 ctx.fillText(text, 7, 0);
	 </pre>
	 <p> (2) EM&rsquo;s aren&rsquo;t supported in &lt;canvas&gt; so they&rsquo;ll have to be converted to PX&rsquo;s. We can find the conversion ratio for converting between PT, PC, EM, EX, PX and so-forth by creating an element with the same font-properties in DOM, and setting the width to the format to be measured;&nbsp; for instance, to capture the EM -&gt; PX conversion, we&rsquo;d measure the DOM element with a &ldquo;height: 1em&rdquo;, the resulting offsetHeight would be how many PX&rsquo;s are in each EM.
	 <pre class="prettyprint">
	 var font = &ldquo;20px sans-serif&rdquo;
	 var d = document.createElement(&rdquo;span&rdquo;);
	 d.style.cssText = &ldquo;font: &ldquo; + font + &ldquo; height: 1em; display: block&rdquo;
	 // the value to multiply PX&rsquo;s by to convert to EM&rsquo;s
	 var EM2PX = 1 / d.offsetHeight;
	 </pre>
	 <p> <h3 id="toc-topic-subtopic">Preventing alpha-multiplication</h3>
	 <p> In a more complex example, such as the Neon effect found on Line25, the shadowBlur property must be used to emulate the effect properly.&nbsp; Since the Neon effect relies on multiple shadows, we run into a problem; in &lt;canvas&gt; each vector object can only have one shadow.&nbsp; So, in order to draw multiple shadows, you must draw multiple versions of the text on top of itself.&nbsp; This results in alpha multiplication, and ultimately jagged edges.
	 <p>
	 <p><img src="./media/pastedGraphic_2.png" alt="pastedGraphic_2.png" width="500" height="194" /><br />
	   I tried running ctx.fillStyle = &ldquo;rgba(0,0,0,0)&rdquo; or &ldquo;transparent&rdquo; to hide the text, while displaying the shadow...&nbsp; however, this attempt was futile;&nbsp; since the shadow is a multiplication of the fillStyle alpha, the shadow can never be more opaque than the fillStyle.
	 <p> Luckily, there is a way around this, we can draw the shadow offset from the text, keeping them separated (so they&rsquo;re not overlapping), and thereby hiding the text off the side of the screen:&nbsp;
	 <pre class="prettyprint">
	 var text = &ldquo;Hello world!&rdquo;
	 var blur = 10;
	 var width = ctx.measureText(text).width + blur * 2;
	 ctx.textBaseline = &ldquo;top&rdquo;
	 ctx.shadowColor = &ldquo;#000&rdquo;
	 ctx.shadowOffsetX = width;
	 ctx.shadowOffsetY = 0;
	 ctx.shadowBlur = blur;
	 ctx.fillText(text, -width, 0);
	 </pre>
	 <p> <h3 id="toc-topic-subtopic">Clipping around a text block</h3>
	 <p> To clean this up a bit we can prevent the fillText from being drawn in the first place (while allowing the shadow to be drawn) by adding a clipping path.&nbsp; In order to create a clipping path surrounding the text, we need to know the height of the text (called the &ldquo;em-height&rdquo; historically the height of the letter &ldquo;M&rdquo; on a printing press), and the width of the text.&nbsp; We can get the width using ctx.measureText().width, however, ctx.measureText().height doesn&rsquo;t exist.
	 <p> Luckily, through CSS hack-ardry <i>(see</i> <i><a href="http://mudcu.be/journal/html5-typographic-metrics/">Typographic Metrics</a></i> <i>for more ways to fix older implementations of &lt;canvas&gt; using CSS measurements)</i>, we can find the height of the text through measuring the offsetHeight of a &lt;span&gt; with the same font-properties:
	 <pre class="prettyprint">
	 var d = document.createElement(&rdquo;span&rdquo;);
	 d.font = &ldquo;20px arial&rdquo;
	 d.textContent = &ldquo;Hello world!&rdquo;
	 var emHeight = d.offsetHeight;
	 </pre>
	 <p> From there, we can create a rectangle to use as a clipping path; enclosing the &ldquo;shadow&rdquo; while removing the dummy-shape.
	 <pre class="prettyprint"> 
	 ctx.rect(0, 0, width, emHeight);
	 ctx.clip();
	 </pre>
	 <p> Tying it all together, and optimizing as we go&mdash;if a shadow has no blur, fillText can be used to the same effect, saving us from setting up the clipping mask:
	 <pre class="prettyprint">
	 var width = ctx.measureText(text).width;
	 var style = shadowStyles[text];
	 // add a background to the current effect
	 ctx.fillStyle = style.background;
	 ctx.fillRect(0, offsetY, ctx.canvas.width, textHeight - 1)
	 // parse text-shadows from css
	 var shadows = parseShadow(style.shadow);
	 // loop through the shadow collection
	 var n = shadows.length; while(n--) {
		 var shadow = shadows[n];
		 var totalWidth = width + shadow.blur * 2;
		 ctx.save();
		 ctx.beginPath();
		 ctx.rect(offsetX - shadow.blur, offsetY, offsetX + totalWidth, textHeight);
		 ctx.clip();
		 if (shadow.blur) { // just run shadow (clip text)
			 ctx.shadowColor = shadow.color;
			 ctx.shadowOffsetX = shadow.x + totalWidth;
			 ctx.shadowOffsetY = shadow.y;
			 ctx.shadowBlur = shadow.blur;
			 ctx.fillText(text, -totalWidth + offsetX, offsetY + metrics.top);
		 } else { // just run pseudo-shadow
			 ctx.fillStyle = shadow.color;
			 ctx.fillText(text, offsetX + (shadow.x||0), offsetY - (shadow.y||0) + metrics.top);
		 }
		 ctx.restore();
	 }
	 // drawing the text in the foreground
	 if (style.color) {
		 ctx.fillStyle = style.color;
		 ctx.fillText(text, offsetX, offsetY + metrics.top);
	 }
	 // jump to next em-line
	 ctx.translate(0, textHeight);
	   </pre>
	 <p> Since you&rsquo;re not going to want to enter all these &lt;canvas&gt; commands manually, I&rsquo;ve included a simple text-shadow parser in the demo source; this way you can feed it CSS commands and have it generate &lt;canvas&gt; commands. &nbsp;
	   Now, our &lt;canvas&gt; elements have a whole range of styles it can tie into.&nbsp; These same shadow-effects can be used on any vector object, from WebFonts to complex shapes imported from SVGs, to generative vector shapes, and so on!
	 <p> <strong><i>View</i> <a href="./Text-Effects.html">Text-Shadows in &lt;canvas&gt;</a> <i>effects.</i>
	 </strong>
	 <p class="p5"><img src="./media/pastedGraphic_3.png" alt="pastedGraphic_3.png" width="599" height="168" /><br />
	 <p> <h3 id="toc-topic-subtopic">Intermission (tangent on pixel-pushing)</h3>
	 <p> In writing this section of the article, the Stereoscopic example made me curious.&nbsp; How hard it would be to create a 3D-movie-screen effect using &lt;canvas&gt; and two images taken from slightly different perspectives?&nbsp; Apparently, not too hard.&nbsp; The following kernel combines the red channel of the first image (data) w/ the cyan channel of the second image (data2):
	 <pre class="prettyprint">
	 data[i] = data[i] * 255 / 0xFF;
	 data[i+1] = 255 * data2[i+1] / 0xFF;
	 data[i+2] = 255 * data2[i+2] / 0xFF;
	 </pre>
	 <p> Visit the <a href="./Stereoscopy.html"><strong>Stereoscopic demo</strong></a> to see how to create images to be enhanced with 3D glasses (cyan/magenta).&nbsp; Now, someone just needs to duct-tape two iPhones to their forehead, click &ldquo;record video&rdquo; at the same time, and we could make our own 3D movies in HTML5.&nbsp; Any volunteers?
	 <p>
	 <p class="p5"><img src="./media/pastedGraphic_5.png" alt="pastedGraphic_5.png" /><br />
	   <img src="./media/3d_glasses.png" width="74" height="18" alt="3D Glasses" />
	 <p>
	 <h2 id="neon-rainbow"><b>Neon-rainbow, zebra-reflection&mdash;chaining effects.</b></h2>
	 Chaining multiple effects in &lt;canvas&gt; can be simple, but a basic knowledge of the globalCompositeOperation (GCO) is required.&nbsp; To compare the operations to GIMP (or Photoshop):&nbsp; there are 12 GCO&rsquo;s in &lt;canvas&gt;&nbsp; <i>darker</i>, and <i>lighter</i> can be thought of as layer blend-modes;&nbsp; the other 10 operations are applied to the layers as alpha masks (one layer removes the pixels of the other layer).&nbsp; The globalCompositeOperation ties &ldquo;layers&rdquo; (or in our case, strings of code) together, combining them in new and exciting ways:
	 <p>
	 <p><img src="./media/pastedGraphic_6.png" alt="pastedGraphic_6.png" width="512" height="401" /><br />
	   The <a href="./globalCompositeOperation.html">globalCompositeOperation chart</a> shows GCO modes at work; this chart uses a large portion of the color-spectrum and multiple levels of alpha transparency in order to see in detail what to expect.&nbsp; I would recommend checking out Mozilla&rsquo;s <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">globalCompositeOperation reference</a> for textual descriptions. For further research, you can learn how the operations work in Porter Duff&rsquo;s <i><a href="http://keithp.com/~keithp/porterduff/">Compositing Digital Images</a></i>. &nbsp;
	 <p> My favorite mode is globalCompositeOperation=&rdquo;lighter&rdquo;.&nbsp; Lighter mixes the appended pixels similar to how light mixes; when red, green and white light are at full-intensity, we see white-light.&nbsp; It&rsquo;s a exciting feature to play around with, especially when the &lt;canvas&gt; is set to a low globalAlpha;&nbsp; enabling finer control, and smoother edges.&nbsp; Lighter has been put to many uses, my recent favorite being a HTML5 desktop background creator found at <a href="http://weavesilk.com/">http://weavesilk.com/</a>.&nbsp; One of my demos, <a href="http://mudcu.be/labs/JS1k/BreathingGalaxies.html">Breathing Galaxies</a> (JS1k), also uses the lighter mode&mdash;drawing patterns from these two examples you start to see what effect this mode yields.
	 <p> <b>NOTE:</b> There is some missing support for some of the GCO modes across the browsers that needs to be sorted out.&nbsp; There are six-modes that work across browsers (in Chrome, Safari, Firefox, and Opera):&nbsp; <b>source-over, source-atop, destination-over, destination-out, lighter, and xor</b>. Hopefully this will be sorted out in coming releases, for more information visit <a href="http://www.rekim.com/tag/globalcompositeoperation/">globalCompositeOperation browser handling</a>.
	 <p> <h3 id="toc-topic-subtopic">Neon-Rainbow Jitter Effect</h3>
	 <p> In the following demo, we&rsquo;re going to achieve a <i>Photoshop-like</i> neon-rainbow-glow with a jittered outline, by chaining effects together using the globalCompositeOperation (source-in, lighter, and darker).&nbsp; This demo is a progression of the &ldquo;Text-Shadows in &lt;canvas&gt;&rdquo; demo, using the same strategy in separating the shadow from the text (see previous section):
	 <p>
	 <p><img src="./media/pastedGraphic_7.png" alt="pastedGraphic_7.png" width="500" height="166" /><br />
	   <i><strong>View</strong></i> <strong><a href="./Text-Effects.html#neon+rainbow+jitter">Neon-Rainbow Jitter</a> <i>effect.</i></strong><i></i>
   <pre class="prettyprint">
   function neonLightEffect() {
	   var text = "alert('"+String.fromCharCode(0x2665)+"')";
	   var font = "120px Futura, Helvetica, sans-serif";
	   var jitter = 25; // the distance of the maximum jitter
	   var offsetX = 30;
	   var offsetY = 70;
	   var blur = getBlurValue(100);
	   // save state
	   ctx.save();
	   ctx.font = font;
	   // calculate width + height of text-block
	   var metrics = getMetrics(text, font);
	   // create clipping mask around text-effect
	   ctx.rect(offsetX - blur/2, offsetY - blur/2, offsetX + metrics.width + blur, metrics.height + blur);
	   ctx.clip();
	   // create shadow-blur to mask rainbow onto (since shadowColor doesn't accept gradients)
	   ctx.save();
	   ctx.fillStyle = "#fff";
	   ctx.shadowColor = "rgba(0,0,0,1)";
	   ctx.shadowOffsetX = metrics.width + blur;
	   ctx.shadowOffsetY = 0;
	   ctx.shadowBlur = blur;
	   ctx.fillText(text, -metrics.width + offsetX - blur, offsetY + metrics.top);
	   ctx.restore();
	   // create the rainbow linear-gradient
	   var gradient = ctx.createLinearGradient(0, 0, metrics.width, 0);
	   gradient.addColorStop(0, "rgba(255, 0, 0, 1)");
	   gradient.addColorStop(0.15, "rgba(255, 255, 0, 1)");
	   gradient.addColorStop(0.3, "rgba(0, 255, 0, 1)");
	   gradient.addColorStop(0.5, "rgba(0, 255, 255, 1)");
	   gradient.addColorStop(0.65, "rgba(0, 0, 255, 1)");
	   gradient.addColorStop(0.8, "rgba(255, 0, 255, 1)");
	   gradient.addColorStop(1, "rgba(255, 0, 0, 1)");
	   // change composite so source is applied within the shadow-blur
	   ctx.globalCompositeOperation = "source-atop";
	   // apply gradient to shadow-blur
	   ctx.fillStyle = gradient;
	   ctx.fillRect(offsetX - jitter/2, offsetY, metrics.width + offsetX, metrics.height + offsetY);
	   // change composite to mix as light
	   ctx.globalCompositeOperation = "lighter";
	   // multiply the layer
	   ctx.globalAlpha = 0.7
	   ctx.drawImage(ctx.canvas, 0, 0);
	   ctx.drawImage(ctx.canvas, 0, 0);
	   ctx.globalAlpha = 1
	   // draw white-text ontop of glow
	   ctx.fillStyle = "rgba(255,255,255,0.95)";
	   ctx.fillText(text, offsetX, offsetY + metrics.top);
	   // created jittered stroke
	   ctx.lineWidth = 0.80;
	   ctx.strokeStyle = "rgba(255,255,255,0.25)";
	   var i = 10; while(i--) { 
		   var left = jitter / 2 - Math.random() * jitter;
		   var top = jitter / 2 - Math.random() * jitter;
		   ctx.strokeText(text, left + offsetX, top + offsetY + metrics.top);
	   }	
	   ctx.strokeStyle = "rgba(0,0,0,0.20)";
	   ctx.strokeText(text, offsetX, offsetY + metrics.top);
	   ctx.restore();
   };
   </pre><p> <h3 id="toc-topic-subtopic">Zebra Reflection Effect</h3>
	 <p> The Zebra Reflection effect was inspired by <a href="http://www.webdesignerwall.com/demo/css-gradient-text">WebDesignerWall</a>&rsquo;s excellent resource on how to spice up your page with CSS.&nbsp; This takes the idea a little bit further, creating a &ldquo;reflection&rdquo; for the text&mdash;such as what you might see in iTunes.&nbsp; The effect combines the fillColor (white), createPattern (zebra.png), and linearGradient (shine);&nbsp; this illustrates the ability to apply multiple fill types to each vector object:
	 <p>
	 <p><img src="./media/pastedGraphic_8.png" alt="pastedGraphic_8.png" width="600" height="199" /><br />
	   <i><strong>View</strong></i> <strong><a href="./Text-Effects.html#pattern+gradient+reflect">Zebra Reflection</a> <i>effect.</i></strong><i></i>
   <pre class="prettyprint">
   function sleekZebraEffect() {
	   // inspired by - http://www.webdesignerwall.com/demo/css-gradient-text/
	   var text = "Sleek Zebra...";
	   var font = "100px Futura, Helvetica, sans-serif";
	   // save state
	   ctx.save();
	   ctx.font = font;
	   // getMetrics calculates:
	   // width + height of text-block
	   // top + middle + bottom baseline
	   var metrics = getMetrics(text, font);
	   var offsetRefectionY = -20;
	   var offsetY = 70;
	   var offsetX = 60;
	   // throwing a linear-gradient in to shine up the text
	   var gradient = ctx.createLinearGradient(0, offsetY, 0, metrics.height + offsetY);
	   gradient.addColorStop(0.1, '#000');
	   gradient.addColorStop(0.35, '#fff');
	   gradient.addColorStop(0.65, '#fff');
	   gradient.addColorStop(1.0, '#000');
	   ctx.fillStyle = gradient
	   ctx.fillText(text, offsetX, offsetY + metrics.top);
	   // draw reflected text
	   ctx.save();
	   ctx.globalCompositeOperation = "source-over";
	   ctx.translate(0, metrics.height + offsetRefectionY)
	   ctx.scale(1, -1);
	   ctx.font = font;
	   ctx.fillStyle = "#fff";
	   ctx.fillText(text, offsetX, -metrics.height - offsetY + metrics.top);
	   ctx.scale(1, -1);
	   // cut the gradient out of the reflected text 
	   ctx.globalCompositeOperation = "destination-out";
	   var gradient = ctx.createLinearGradient(0, offsetY, 0, metrics.height + offsetY);
	   gradient.addColorStop(0.0, 'rgba(0,0,0,0.65)');
	   gradient.addColorStop(1.0, '#000');
	   ctx.fillStyle = gradient;
	   ctx.fillRect(offsetX, offsetY, metrics.width, metrics.height);
	   // restore back to original transform state
	   ctx.restore();
	   // using source-atop to allow the transparent .png to show through to the gradient
	   ctx.globalCompositeOperation = "source-atop";
	   // creating pattern from <image> sourced
	   ctx.fillStyle = ctx.createPattern(image, 'repeat');
	   // fill the height of two em-boxes, to encompass both normal and reflected state
	   ctx.fillRect(offsetX, offsetY, metrics.width, metrics.height * 2);
	   ctx.restore();
   };
   </pre>
	 <p>
	 <h2 id="inner-shadow"><b>Inner/outer shadows in &lt;canvas&gt;</b></h2>
	 The &lt;canvas&gt; specs doesn&rsquo;t touch on the subject of &ldquo;inner&rdquo; vs. &ldquo;outer&rdquo; shadows.&nbsp; In fact, at first appearance, you may expect &ldquo;inner&rdquo; shadow isn&rsquo;t supported.&nbsp; This is not the case.&nbsp; It&rsquo;s just a bit tricker to enable ;)&nbsp; As proposed in a recent post from <a href="http://weblog.bocoup.com/can-i-draw-an-inset-shadow-with-the-html5-canvas-api">F1LT3R</a>, you can create inner-shadows using the unique properties of clockwise vs. anti-clockwise winding rules.&nbsp; To do this, you create an &ldquo;inner-shadow&rdquo; by drawing container rectangle, and then, using opposite winding rules, draw a cutout shape&mdash;creating the inverse of the shape. &nbsp;
	 <p> The following example allows for the inner-shadow and fillStyle to be stylized with color+gradient+pattern simultaneously.&nbsp; You can specify pattern rotation individually; notice the zebra stripes are now perpendicular to each-other.&nbsp; A clipping mask the size of the bounding-box is used removing the need for a super-large container to enclose the cutout shape&mdash;improving the speed by preventing the unnecessary parts of the shadow from being processed.
	 <p>
	 <p><img src="./media/pastedGraphic_9.png" alt="pastedGraphic_9.png" /><br />
	   <i><strong>View</strong></i> <strong><a href="./Text-Effects.html#innershadow+pattern+gradient">Inner-shadow</a> <i>effect.</i></strong><i></i>
   <pre class="prettyprint">
   
	  function innerShadow() {
		  function drawShape() { // draw anti-clockwise
			  ctx.arc(0, 0, 100, 0, Math.PI * 2, true); // Outer circle
			  ctx.moveTo(70, 0);
			  ctx.arc(0, 0, 70, 0, Math.PI, false); // Mouth
			  ctx.moveTo(-20, -20);
			  ctx.arc(30, -30, 10, 0, Math.PI * 2, false); // Left eye
			  ctx.moveTo(140, 70);
			  ctx.arc(-20, -30, 10, 0, Math.PI * 2, false); // Right eye
		  };
		  var width = 200;
		  var offset = width + 50;
		  var innerColor = "rgba(0,0,0,1)";
		  var outerColor = "rgba(0,0,0,1)";
		  ///
		  ctx.translate(150, 170);
		  // apply inner-shadow
		  ctx.save();
		  ctx.fillStyle = "#000";
		  ctx.shadowColor = innerColor;
		  ctx.shadowBlur = getBlurValue(120);
		  ctx.shadowOffsetX = -15;
		  ctx.shadowOffsetY = 15;
		  // create clipping path (around blur + shape, preventing outer-rect blurring)
		  ctx.beginPath();
		  ctx.rect(-offset/2, -offset/2, offset, offset);
		  ctx.clip();
		  // apply inner-shadow (w/ clockwise vs. anti-clockwise cutout)
		  ctx.beginPath();
		  ctx.rect(-offset/2, -offset/2, offset, offset);
		  drawShape();
		  ctx.fill();
		  ctx.restore();
		  // cutout temporary rectangle used to create inner-shadow
		  ctx.globalCompositeOperation = "destination-out";
		  ctx.fill();
		  // prepare vector paths
		  ctx.beginPath();
		  drawShape();
		  // apply fill-gradient to inner-shadow
		  ctx.save();
		  ctx.globalCompositeOperation = "source-in";
		  var gradient = ctx.createLinearGradient(-offset/2, 0, offset/2, 0);
		  gradient.addColorStop(0.3, '#ff0');
		  gradient.addColorStop(0.7, '#f00');
		  ctx.fillStyle = gradient;
		  ctx.fill();
		  // apply fill-pattern to inner-shadow
		  ctx.globalCompositeOperation = "source-atop";
		  ctx.globalAlpha = 1;
		  ctx.rotate(0.9);
		  ctx.fillStyle = ctx.createPattern(image, 'repeat');
		  ctx.fill();
		  ctx.restore();
		  // apply fill-gradient
		  ctx.save();
		  ctx.globalCompositeOperation = "destination-over";
		  var gradient = ctx.createLinearGradient(-offset/2, -offset/2, offset/2, offset/2);
		  gradient.addColorStop(0.1, '#f00');
		  gradient.addColorStop(0.5, 'rgba(255,255,0,1)');
		  gradient.addColorStop(1.0, '#00f');
		  ctx.fillStyle = gradient
		  ctx.fill();
		  // apply fill-pattern
		  ctx.globalCompositeOperation = "source-atop";
		  ctx.globalAlpha = 0.2;
		  ctx.rotate(-0.4);
		  ctx.fillStyle = ctx.createPattern(image, 'repeat');
		  ctx.fill();
		  ctx.restore();
		  // apply outer-shadow (color-only without temporary layer)
		  ctx.globalCompositeOperation = "destination-over";
		  ctx.shadowColor = outerColor;
		  ctx.shadowBlur = 40;
		  ctx.shadowOffsetX = 15;
		  ctx.shadowOffsetY = 10;
		  ctx.fillStyle = "#fff";
		  ctx.fill();
	  };	
   </pre>
	 <p> From these examples you can see, using globalCompositeOperation, we can chain-effects together, producing more elaborate effects (utilizing masking and blending).&nbsp; The screen is your oyster ;)
	 <p>
	 <h2 id="spaceage"><b>Spaceage&mdash;generative effects.</b></h2>
	 &nbsp;In &lt;canvas&gt;, going from the unicode character 0x2708:
	 <p><img src="./media/pastedGraphic_10.png" alt="pastedGraphic_10.png" width="270" height="257" /><br />
	 <p>... to this shaded example:
	 <p><img src="./media/pastedGraphic_11.png" alt="pastedGraphic_11.png" width="270" height="200" /><br />
	   ... can be achieved by multiple calls to ctx.strokeText() with a thin lineWidth (0.25), while slowly decreasing the x-offset and alpha;&nbsp; giving our vector elements the feeling of motion.&nbsp;
	 <p> By mapping the elements XY position to a sine/cosine wave, and cycling through colors using the HSL property, we can create more interesting effects, such as this &ldquo;biohazard&rdquo; example:
	 <p>
	 <p><img src="./media/pastedGraphic_12.png" alt="pastedGraphic_12.png" /><br />
	   <h3 id="toc-topic-subtopic">HSL:&nbsp; Hue, Saturation, Lightness (1978)</h3>
	 <p> HSL is a newly supported format in the CSS3 specs.&nbsp; Where HEX was designed for computers, HSL is designed to be human readable.&nbsp;
	 <p> Illustrating the ease of HSL; to cycle through the color-spectrum, we&rsquo;d simply increment the &ldquo;hue&rdquo; from 360; the hue is mapped to the spectrum in cylindric fashion.&nbsp; Lightness controls how how dark/light the color is; 0% indicates a black pixel, whereas 100% indicates a white pixel.&nbsp; Saturation controls how bright or vivid a color is; grey&rsquo;s are created with a saturation of 0%, and vivid colors are created using a value of 100%.
	 <p>
	 <p class="p5"><img src="./media/pastedGraphic_13.png" alt="pastedGraphic_13.png" width="200" height="200" /><br />
	 <p> Since HSL is a recent standard, you may wish to continue supporting older browsers, which is possible via color-space conversion.&nbsp; The following code accepts an HSL object { H: 360, S: 100, L: 100} and outputs a RGB object { R: 255, G: 255, B: 255 }.&nbsp; From there, you can use those values to create your rgb or rgba string.  For more in depth information see Wikipedia&rsquo;s insightful article on <a href="http://en.wikipedia.org/wiki/HSL_and_HSV">HSL</a>.
	 <pre class="prettyprint">
	 // HSL (1978) = H: Hue / S: Saturation / L: Lightness
	 HSL_RGB = function (o) { //&nbsp; { H: 0-360, S: 0-100, L: 0-100 }
		 var H = o.H / 360,
			 S = o.S / 100,
			 L = o.L / 100,
			 R, G, B, _1, _2;
		 function Hue_2_RGB(v1, v2, vH) {
			 if (vH < 0) vH += 1;
			 if (vH > 1) vH -= 1;
			 if ((6 * vH) < 1) return v1 + (v2 - v1) * 6 * vH;
			 if ((2 * vH) < 1) return v2;
			 if ((3 * vH) < 2) return v1 + (v2 - v1) * ((2 / 3) - vH) * 6;
			 return v1;
		 }
		 if (S == 0) { // HSL from 0 to 1
			 R = L * 255;
			 G = L * 255;
			 B = L * 255;
		 } else {
			 if (L < 0.5) _2 = L * (1 + S);
			 else _2 = (L + S) - (S * L);
			 _1 = 2 * L - _2;
			 R = 255 * Hue_2_RGB(_1, _2, H + (1 / 3));
			 G = 255 * Hue_2_RGB(_1, _2, H);
			 B = 255 * Hue_2_RGB(_1, _2, H - (1 / 3));
		 }
		 return {
			 R: R,
			 G: G,
			 B: B
		 };
	 };
	 </pre>
	 <p> <h3 id="toc-topic-subtopic">Creating animations with requestAnimationFrame</h3>
	 <p> In the past, to create animations in Javascript, there was two choices; setTimeout, and setInterval.
	 <p><i>requestAnimationFrame</i>, is the new standard here to replace both; saving the world electricity (and your computer a few heartbeats) by allowing the browser to regulate animations based on available resources.&nbsp; Some important features include:
   <li> When a user exists the frame, the animation can slow down or stop completely, to prevent the use of unneeded resources. &nbsp;
   <li> There is a limit cap to the frame-rate at 60FPS.&nbsp; The reason for this is it&rsquo;s well above the level humans can notice (most humans by 30FPS see animation being &ldquo;fluid&rdquo;).
	 <p> At the time of writing, vender specific prefixes are required to use requestAnimationFrame. Paul Irish created a shim layer that has cross-vender support, in <a href="http://paulirish.com/2011/requestanimationframe-for-smart-animating/">requestAnimationFrame for smart animating</a>:
	 <pre class="prettyprint">
	   // shim layer with setTimeout fallback
	   window.requestAnimFrame = (function(){
		 return  window.requestAnimationFrame       || 
				 window.webkitRequestAnimationFrame || 
				 window.mozRequestAnimationFrame    || 
				 window.oRequestAnimationFrame      || 
				 window.msRequestAnimationFrame     || 
				 function(/* function */ callback, /* DOMElement */ element){
				   window.setTimeout(callback, 1000 / 60);
				 };
	   })();</pre>
	 Taking that a bit further, the more ambitious might tie this together with a poly-fill such as <a href="https://github.com/neonux/requestAnimationFrame.js">requestAnimationFrame.js</a> (there are a few features to be worked out) that would support older browsers to a further extent, while switching to this new standard.
	 <p> The following example shows how to create an animation, sending thousands of calls to strokeText through a low alpha without stalling the browser.  The controls are a bit strange, but it produces some cool results:
	 <p><i><strong>View</strong></i> <strong><a href="./Text-Effects.html#spaceage">Spaceage</a> <i>effect.</i></strong><i></i>
	 
	 <pre class="prettyprint">
	 (function animate() {
		 var i = 50; while(i--) {
			 if (n > endpos) return;
			 n += definition;
			 ctx.globalAlpha = (0.5 - (n + startpos) / endpos) * alpha;
			 if (doColorCycle) {
				 hue = n + color;
				 ctx.strokeStyle = "hsl(" + (hue % 360) + ",99%,50%)"; // iterate hue
			 }
			 var x = cos(n / cosdiv) * n * cosmult; // cosine
			 var y = sin(n / sindiv) * n * sinmult; // sin
			 ctx.strokeText(text, x + xoffset, y + yoffset); // draw rainbow text
		 }
		 timeout = window.requestAnimationFrame(animate, 0);
	 })();
   </pre>
	 <p class="p5"><img src="./media/pastedGraphic_14.png" alt="pastedGraphic_14.png" width="512" height="279" />  
	 <p class="p5"><img src="./media/pastedGraphic_16.png" alt="pastedGraphic_16.png" width="512" height="170" />  
	 <p class="p5"><img src="./media/pastedGraphic_17.png" alt="pastedGraphic_17.png" width="512" height="152" /><br />
	 <p> With support from across browser vendor-sphere, there is no question about the future of &lt;canvas&gt; it can be easily ported to the iPhone/Android/Desktop executables using <a href="http://www.phonegap.com/">PhoneGap</a>, or <a href="http://www.appcelerator.com/products/titanium-cross-platform-application-development/">Titanium</a>.&nbsp; I&rsquo;m looking forwards to the future of web-apps, especially interactive <a href="http://infosthetics.com/">infosthetics</a>&mdash;the art of making information beautiful, and (hopefully) understandable.&nbsp; 
	 <p> <a href="./"><b>Source-code, and demos inside.</b></a>
	 <p>
  
  {% endblock %}